//get message


import ServerMiddleware from "../js/middleware_server.mjs";
import EventProcessor from "../js/event_processor.mjs";

/*
Table structure (postgres)
CREATE TABLE messages (id SERIAL PRIMARY KEY, message text, area text, pid text)


CREATE TABLE documents
(
    name character varying(100) NOT NULL,
    content text NOT NULL,
    CONSTRAINT document_name UNIQUE (name)
)


*/

let getServerId = function(){
	//this is just a key to flag that messages are from the server
	//it just has to be a value that can't be generated by a client
	//messages with this pid will not be filtered
	//in theory, this could be made more secure by randomising each reset and storing in model
	//also an environment var could be used to make it configurable
	//for now this will suffice
	return "server__server";
};

let getState  = async function (area,client){
	//retrieve model from the database
	let doc_name = "zkss_"+area;
	return client.query('  SELECT name, content FROM documents '+
								  ' WHERE  name=$1 ',[doc_name]);
	
};
let saveState = async function (area,state,client){
	let doc_name = "zkss_"+area;
	let doc_state = state;
	return client.query('  INSERT INTO documents (name, content) '+
            ' VALUES ($1, $2) ON CONFLICT (name) DO UPDATE '+
            ' SET content=$2 WHERE documents.name=$1',[doc_name,doc_state]);
};


export default async function(request,response,client) {
	var responseObj = {
		success:false,
		data:{}
	};
    try{
		
		let params = request.body;
		if(!params.hasOwnProperty("kind")||
			!params.hasOwnProperty("area")||
			!params.hasOwnProperty("pid")){
			responseObj.data = "missing parameter";
			response.send(responseObj);
			return;
		}
		let kind = params.kind;
		let area = params.area;
		let playerId = params.pid;
		await client.connect();
		
		if(kind=="reset"){
			//TODO: nukes the whole table....
			
			//generate an empty model for population later
			let serverData = new ServerMiddleware();
			await client.query(' DELETE FROM messages ' );
			await client.query(" DELETE FROM documents where name like 'zkss_%' " );
			await saveState(area,serverData.model,client);
			
			
			responseObj.success = true;
			responseObj.data = "reset successful";
		}
		if(kind == "send"){
			if(!params.hasOwnProperty("message")){
				responseObj.data = "unkonwn message";
				response.send(responseObj);
				client.end();
				return;
			}
			let message = params.message;
			await client.query(' INSERT INTO messages(message,area,pid) values ($1,$2,$3) ',[message,area,playerId]);
			
			let dbModelResult = await getState(area,client);
			let dbModel = JSON.parse(dbModelResult.rows[0].content);
			let serverData = new ServerMiddleware();
			serverData.model = dbModel;
			let eventProcessor = new EventProcessor(serverData);
			eventProcessor.processEvent(message);
			for(let i=0;i<serverData.internalMessageBuffer.length;i+=1){
				let serverMsg =serverData.internalMessageBuffer[i];
				await client.query(' INSERT INTO messages(message,area,pid) values ($1,$2,$3) ',[serverMsg,area,getServerId()]);
			}
			await saveState(area,serverData.model,client);
			
			
			responseObj.success = true;
			responseObj.data = "added message";
			response.send(responseObj);
		}
		
		if(kind == "get"){
			if(!params.hasOwnProperty("id") ){
				responseObj.data = "unkonwn id";
				response.send(responseObj);
				client.end();
				return;
			}
			let id = params.id;
			let result = await client.query('SELECT id,message,pid FROM messages where id > $1 and area = $2 ORDER BY id  ',[id,area]);
			let resultData = result.rows;
			
			if(resultData.length>0){
				let dbModelResult = await getState(area,client);
				let dbModel = JSON.parse(dbModelResult.rows[0].content);
				let serverData = new ServerMiddleware();
				serverData.model = dbModel;
				for(let i=resultData.length-1;i>=0;i-=1){
					let msgToValidate = resultData[i];
					let canBeSent = serverData.messageCanBeSent(msgToValidate.message,playerId,msgToValidate.pid,getServerId());
					if(!canBeSent){
						resultData.splice(i,1);
					}
				}
			}
			
			responseObj.success = true;
			responseObj.data = resultData;
			response.send(responseObj);			
		}
		client.end();
    }catch(e){
        responseObj.data ="error: "+e;
        response.send(responseObj);
    }
}

