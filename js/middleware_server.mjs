
import Au from "./globals.mjs";
import BaseMiddleware from "./middleware_base.mjs";
//use for interacting with the game model via the client-side version of the game
export default  class ServerMiddleware extends BaseMiddleware {
  constructor() {
    super();
    this.internalMessageBuffer = [];//used by the server to send messages to the client
  }
  
  clearTask(key){
    super.clearTask(key);
    let self = this;
    //TODO: change this to send a message to the players instead of alert
    //check all tasks are clear, if so, end game
    let allClear = true;
    let keys = Object.keys(self.model.varTasks);
    for(let i=0;i<keys.length;i+=1){
        let task = self.model.varTasks[keys[i]];
        if(!task.isClear){
            allClear = false;
            break;
        }
    }
    if(allClear){
        self.sendMessage({
          kind:Au.EVENTS.GAME_OVER,
          imposterwin:false,
          description:"all tasks clear!",
      });
      
    }
    
    
  }
  
  killPlayer(player,from){
    super.killPlayer(player,from);
    let self = this;
    //TODO: change this to send a message to the players instead of alert
    //check number of alive
    let aliveCount = 0;
    let imposterCount = 0;
    let keys = Object.keys(self.model.varPlayers);
    for(let i=0;i<keys.length;i+=1){
        let player = self.model.varPlayers[keys[i]];
        if(player.isAlive){
            aliveCount+=1;
        }
        if(player.isImposter){
            imposterCount+=1;
        }
    }
    if(imposterCount>=aliveCount){
        self.sendMessage({
          kind:Au.EVENTS.GAME_OVER,
          imposterwin:true,
          description:"imposters outnumber innocents",
      });
    }
    if(imposterCount<=0){
        self.sendMessage({
          kind:Au.EVENTS.GAME_OVER,
          imposterwin:false,
          description:"no imposters remain",
      });
    }
  }
  
  castVote(vote){
    super.castVote(vote);
    let self = this;
    let tally = self.tallyVotes();
    
    if(tally.result == self.VOTE_RESULTS.IMPOSTER_WIN){
        //Game over, imposters win with a majority
        self.sendMessage({
          kind:Au.EVENTS.GAME_OVER,
          imposterwin:true,
          description:"imposters voted out all innocents.",
      });
    }
  }
  
  gameOver(imposterwin,description){
    super.gameOver(imposterwin,description);
    let self=this;
    //NOTE: is there anything to do server side? clean up resources?
  }
  
  //-- the following methods are exclusive to the server side.
  //get server-generated messages to be passed to the client
  sendMessage(message){
    let self = this;
    self.internalMessageBuffer.push(message);
  }
  
  
  //filter messages to be sent to the client to block p2p passthrough
  //return true/false if player is allowed to get this message
  //this filter is only applied to messages generated by clients
  //server messages are trusted and should be send after
  messageCanBeSent(messageSring,playerId,senderId,serverId){
    let self = this;
    let message = JSON.parse(messageSring);
    if(senderId==serverId){
      return true;//don't filter server messages
    }
    let player = self.model.varPlayers[playerId];
    if(!player){
      return false;
    }
    //TODO: more specific filters for each message
    
    //clients can't trigger a game over
    if(message.kind == Au.EVENTS.GAME_OVER){
      return false;
    }
    //only get kill messages if you sent it, or you are the target
    if(message.kind == Au.EVENTS.KILL){
      if(message.name!=playerId && message.from!=playerId){
        //return false;//TODO: uncomment this when it's not required for local players to know the alive count (vote tally server side only)
      }
    }
    
    //message passed filter, let it through
    //NOTE: this should probably return false by default to be more safe
    //
    return true;
  }
  
  
  
}

